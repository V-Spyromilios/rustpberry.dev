<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rustpberry.dev</title>

  <!-- JetBrains Mono -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background-color: #0f0f0f;
      color: #f2f2f2;
      padding: 2rem;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .typewriter {
      color: #00ff88;
      white-space: nowrap;
      overflow: hidden;
      border-right: 0.15em solid #00ff88;
      animation: typing 4s steps(40, end), blink-caret 0.75s step-end infinite;
      max-width: 100%;
      font-size: 1.1rem;
      margin: 0 auto 2rem auto;
    }

    @keyframes typing {
      from { width: 0 }
      to { width: 100% }
    }

    @keyframes blink-caret {
      50% { border-color: transparent }
    }

    .contact a {
      display: block;
      margin: 0.3rem 0;
      color: #77c0ff;
      text-decoration: none;
    }

    .contact a:hover {
      color: #ffffff;
    }

    .construction {
      font-size: 1.2rem;
      margin-top: 2rem;
      animation: blink 1.2s steps(1) infinite;
      color: #ffaa00;
    }

    @keyframes blink {
      50% { opacity: 0 }
    }

    .journal {
      margin-top: 4rem;
      text-align: left;
    }

    .journal h2 {
      font-size: 1.4rem;
      border-bottom: 1px solid #444;
      margin-bottom: 1rem;
    }

    .entry {
      margin-bottom: 1.5rem;
    }

    .entry h3 {
      margin-bottom: 0.3rem;
      color: #00c7ff;
    }

    .entry p {
      margin: 0;
      font-size: 0.95rem;
    }

    @media (max-width: 600px) {
      h1 { font-size: 1.5rem; }
      .typewriter { font-size: 1rem; }
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>rustpberry.dev</h1>
    <div class="typewriter">echo "Journaling my journey from mobile to embedded engineering..."</div>

    <div class="contact">
      <a href="mailto:hi@rustpberry.dev">hi@rustpberry.dev</a>
      <a href="https://www.linkedin.com/in/evangelos-spyromilios/" target="_blank">LinkedIn Profile</a>
    </div>

    <div class="construction">🚧 Under Construction 🚧</div>

    <div class="journal">
      <h2>Journal</h2>

      <div class="entry">
        <h3>May 2025 — Joined SEA:ME and started Rust full-time</h3>
        <p>Starting the next chapter — diving into embedded systems, real-time programming, and low-level control. Goodbye UIKit, hello `no_std`.</p>
      </div>

      <div class="entry">
        <h3>April 2025 — Built a Raspberry Pi 5 cluster</h3>
        <p>Running Ubuntu Server, experimenting with k3s and Go microservices to simulate autonomous robotics backend infrastructure.</p>
      </div>

      <div class="entry">
        <h3>March 2025 — Shipped Kioku to App Store</h3>
        <p>My first app, built with SwiftUI and OpenAI API. Gave me the confidence to pivot toward what I really want: robotics, autonomy, and embedded control.</p>
      </div>


    <div class="journal">
  <h2>Live Journal Entry (via Notion)</h2>

  <div class="journal">
  <h2>@State vs @ObservedObject in SwiftUI</h2>
  <div class="notion-entry">
    <!-- Paste your Notion-exported HTML here -->
    <!-- Start from <h1 class="page-title"> down to the end of the article -->
    <h1 class="page-title">@State, @ObservedObject.</h1><p class="page-description"></p></header><div class="page-body"><p id="e0a411f7-39f6-4831-b910-c5f3712430f2" class="">SwiftUI uses the <code><strong>@State</strong></code> property wrapper to allow us to modify values inside a struct, which would normally not be allowed because structs are value types (and all our views are <code>struct</code> !).</p><p id="a4d9609e-7a31-45a6-92f2-d02658d5707e" class=""><em>[ lifespan of </em><em><code>@State</code></em><em> var is the ls of the view, and changes in the var reload the view. ]</em></p><p id="05e11b97-924f-4bb6-af20-b8bce063ddca" class="">When we put <code><strong>@State</strong></code> before a property, we effectively move its storage out from our struct and into shared storage managed by SwiftUI. This means SwiftUI can destroy and recreate our struct whenever needed (and this can happen a lot!), without losing the state it was storing.</p><p id="986f7232-3420-49aa-ad26-6deabfbe768a" class=""><code><strong>@State</strong></code> should be used with simple struct types such as <code><strong>String</strong></code>, <code><strong>Int</strong></code>, and arrays, and generally <strong>shouldn’t be shared with other views</strong>. If you want to share values across views, you should probably use <code><strong>@ObservedObject</strong></code> or <code><strong>@EnvironmentObject</strong></code> instead – both of those will ensure that all views will be refreshed when the data changes.</p><p id="02500673-d6d4-4d22-8b67-075241d92bf2" class="">To re-enforce the local nature of <code><strong>@State</strong></code> properties, Apple recommends you mark them as <code><strong>private</strong></code>, like this:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="db308fbe-1a02-493b-a0d8-b8e2a6baa2e0" class="code"><code class="language-Swift">@State private var username = &quot;&quot;</code></pre><p id="821fbf83-fe40-4f62-94e6-e85588c752e9" class="">
</p><h3 id="352df051-7540-49e3-9dac-01eba2cb3124" class=""><strong><strong>What is @ObservedObject (+ @Published)?</strong></strong></h3><p id="a8f6cf30-4604-4456-8c96-eee99e7fbc5f" class="">For more complex properties – when you have a custom type you want to use that might have multiple properties and methods, or might be shared across multiple views – you will often use <code><strong>@ObservedObject</strong></code> instead.</p><p id="78dcd26a-c88c-49b0-8fc1-96cd24deb2d3" class="">This is very similar to <code><strong>@State</strong></code> except now we’re using an external reference type rather than a simple local property like a string or an integer. You’re still saying that your view depends on data that will change, except now it’s data you’re responsible for managing yourself – you need to create an instance of the class, create its own properties, and so on.</p><p id="e4ed8148-c7f4-455a-9c0d-06707e87e0f7" class=""><span style="border-bottom:0.05em solid"><strong>Whatever type you use with </strong></span><span style="border-bottom:0.05em solid"><strong><code>@ObservedObject</code></strong></span><span style="border-bottom:0.05em solid"><strong> should conform to the </strong></span><span style="border-bottom:0.05em solid"><strong><code>ObservableObject</code></strong></span><span style="border-bottom:0.05em solid"><strong> protocol.</strong></span> When you add properties to observable objects you get to decide whether changes to each property should force views that are watching your object to refresh or not. You usually will, but it’s not required.</p><p id="8df713ee-3951-40bb-aa19-94134fc7b3fb" class="">
</p><p id="2367583e-ad9f-4fbe-badf-abf7f1230026" class="">There are several ways for an observed object to notify views that important data has changed, but the easiest is using the <code><strong>@Published</strong></code> property wrapper. You can also use custom publishers from the Combine framework if you need more control, but realistically this will be very rare.</p><p id="8db7841b-84f6-4fd6-ab19-471271735827" class="">
</p><h3 id="891526c0-cf7a-4d99-9c68-a2de199d389e" class=""><strong><strong>What is @StateObject (+ @Published)?</strong></strong></h3><p id="0249f1f7-b848-4d4b-862f-e2f3d2a2fd59" class="">Somewhere between <code><strong>@State</strong></code> and <code><strong>@ObservedObject</strong></code> lies <code><strong>@StateObject</strong></code>. This is a specialized version of <code><strong>@ObservedObject</strong></code>, and it works in almost exactly the same way: you must conform to the <code><strong>ObservableObject</strong></code> protocol, you can use <code><strong>@Published</strong></code> to mark properties as causing change notifications, and any views that watch an <code><strong>@StateObject</strong></code> will refresh their body when the object changes.</p><p id="41d6c164-39e8-4419-945d-b8e4827182ca" class="">There is one important difference between <code><strong>@StateObject</strong></code> and <code><strong>@ObservedObject</strong></code>, which is <em>ownership</em> – which view <em>created</em> the object, and which view is just <em>watching</em> it.</p><p id="cedd04d1-47e1-4a41-8912-780ab9a47432" class="">The rule is this: <strong>whichever view is the first to create your object must use </strong><strong><code>@StateObject</code></strong><strong>, to tell SwiftUI it is the owner of the data and is responsible for keeping it alive.</strong> All other views must use <code><strong>@ObservedObject</strong></code>, to tell SwiftUI they want to watch the object for changes but don’t own it directly. </p><p id="bf9e1b7d-7e07-4dcd-a915-a7c63d8099fe" class="">→ @State, in the view as private, @ObservedObject  can be put in viewModel, BUT @StateObject is declared in the view! and its lifecycle is managed by SwiftUI. Also conforms to the Obervable Protocol. </p><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Example</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0a37fcd8-47fa-4c37-a516-5ead8bba5701" class="code"><code class="language-Swift">class ViewModel: ObservableObject {
    @Published var count = 0
}

struct ContentView: View {
    @StateObject private var viewModel = ViewModel()

    var body: some View {
        VStack {
            Text(&quot;Count: \(viewModel.count)&quot;)
            Button(&quot;Increment&quot;) {
                viewModel.count += 1
            }
        }
    }
}</code></pre></div></details><h3 id="60ba8507-899c-44fa-bbbe-f9b03fa27606" class=""><strong>What is @EnvironmentObject?</strong></h3><p id="4552d0d7-7767-4f5c-a922-a45f1a9da711" class="">You’ve seen how <code><strong>@State</strong></code> declares simple properties for a type that automatically cause a refresh of the view when it changes, and how <code><strong>@ObservedObject</strong></code> declares a property for an external type that may or may not cause a refresh of the view when it changes. Both of these two must be set by your view, but <code><strong>@ObservedObject</strong></code> might be shared with other views.</p><p id="062cce3c-71cb-4b0e-bb26-9fe5f3a2c350" class="">There’s another type of property wrapper available to use, which is <code><strong>@EnvironmentObject</strong></code>. This is a value that is made available to your views through the application itself – it’s shared data that every view can read if they want to. So, if your app had some important model data that all views needed to read, you could either hand it from view to view to view or just put it into the environment where every view has instant access to it.</p><p id="86fbd286-684f-475c-991b-c6927525867d" class="">Think of <code><strong>@EnvironmentObject</strong></code> as a massive convenience for times when you need to pass lots of data around your app. Because all views point to the same model, if one view changes the model all views immediately update – there’s no risk of getting different parts of your app out of sync.</p><p id="82452cf1-c40a-4f6f-97d4-76af0acc1876" class="">
</p><p id="e72a83c9-272b-452d-8058-cc0e0652e8e5" class=""><mark class="highlight-orange_background"><strong>TLDR</strong></mark>: declare with <code>ObservableObject</code> , init (in @main) as <code>@StateObject</code> pass it <strong><strong><strong><strong><strong><strong><strong><strong>directly</strong></strong></strong></strong></strong></strong></strong></strong> - no need to be passed as argument- in a view with <code>@EnvironmentObject</code></p><h3 id="1e12ddf9-2afe-4b2e-9850-bb3c4aaafdf3" class=""> Sum up the differences</h3><ul id="d677501c-2287-4e77-bdd6-784ce98c3e3f" class="bulleted-list"><li style="list-style-type:disc">Use <code><strong>@State</strong></code> for simple properties that belong to a single view. They should usually be marked <code><strong>private</strong></code>.</li></ul><ul id="1f988791-f335-485e-91a4-c875b560f812" class="bulleted-list"><li style="list-style-type:disc">Use <code><strong>@ObservedObject</strong></code> for complex properties that might belong to several views. Most times you’re using a reference type you should be using <code><strong>@ObservedObject</strong></code> for it.</li></ul><ul id="e777d77f-e564-4bfc-8a6b-9ba42252de4a" class="bulleted-list"><li style="list-style-type:disc">Use <code><strong>@StateObject</strong></code> once for each observable object you use, in whichever part of your code is responsible for creating it (within a SwiftUI view  and without ‘$’).</li></ul><ul id="6c91b886-6524-45e5-88ec-093a0fbba08f" class="bulleted-list"><li style="list-style-type:disc">Use <code><strong>@EnvironmentObject</strong></code> for properties that were created elsewhere in the app, such as shared data.</li></ul><p id="627ade72-cc5b-4406-865e-d16fef88b1da" class="">
</p><p id="302afe38-41cf-4f27-a82e-056fef2eb5e4" class=""><strong>!!</strong> <strong><strong><strong><strong><strong><strong><strong>Notice:</strong></strong></strong></strong></strong></strong></strong></p><p id="647d1e37-a41e-402d-b9c2-ba8294b66534" class="">Prefer to pass ‘viewModel’ as ‘@StateObject’. </p><p id="acd9ab28-40dc-4dbc-8f62-3b932cf08c19" class="">This property wrapper is used when the object is created and owned by the current view or view hierarchy. It ensures that the object&#x27;s lifecycle is managed correctly, and it&#x27;s useful when the object should be persisted and recreated when the view is reloaded (e.g., due to navigation changes). In the scenario of viewModel, using <code><strong>@StateObject</strong></code> for the <code><strong>viewModel</strong></code> property <span style="border-bottom:0.05em solid">implies that the </span><span style="border-bottom:0.05em solid"><code><strong>LoginViewModel</strong></code></span><span style="border-bottom:0.05em solid"> is created and owned by the </span><span style="border-bottom:0.05em solid"><code><strong>Login_View</strong></code></span><span style="border-bottom:0.05em solid"> itself. It ensures that the </span><span style="border-bottom:0.05em solid"><code><strong>LoginViewModel</strong></code></span><span style="border-bottom:0.05em solid"> is recreated when the view is reloaded, such as when navigating back and forth between views.</span></p><p id="3b88a43e-81b5-475e-b401-f985b367b031" class="">
</p><p id="d8bfa8b4-498a-46dc-9882-2998703d2c65" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>And when to use ‘@ObservedObject’</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p id="a3f9d6c1-93b6-495b-b185-fe6a830d1a45" class="">Mainly when a object passed in the viewHierarchy from some parent view. This property wrapper is used when the object is created outside of the current view hierarchy and needs to be observed within the view. It&#x27;s typically used for shared objects or objects passed from a parent view.</p><p id="c417dfa4-5325-441c-a99f-e6551acb97da" class="">In SwiftUI, the <code><strong>@State</strong></code> property wrapper is used for managing local state within a view. When you use the <code><strong>$</strong></code> prefix with a <code><strong>@State</strong></code> property, it gives you a binding to that state, allowing you to read and write its value.</p><p id="68da3bf1-3f59-4e25-b69c-4c373ed97c5d" class="">On the other hand, when you use the <code><strong>@Published</strong></code> property wrapper in an observed object or view model, it allows the published property to be observed and automatically update the views that depend on it.</p><p id="72a8820f-510e-4ada-a90b-05bc0505efc3" class="">Here&#x27;s a breakdown of the usage:</p><ol type="1" id="d74b5db6-02b7-4955-8d87-e6dad8d1acaa" class="numbered-list" start="1"><li><code><strong>@State</strong></code> property:</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d8e2dcfb-3361-4c8b-b20f-b66675c24c32" class="code"><code class="language-Swift">@State private var text: String</code></pre><ul id="7b173e02-3a4c-42d9-8b7e-facae0fad4bf" class="bulleted-list"><li style="list-style-type:disc">Access the value: <code><strong>text</strong></code></li></ul><ul id="f07a132a-45fd-428e-b434-bcc10b573d01" class="bulleted-list"><li style="list-style-type:disc">Get a binding to the state: <code><strong>$text</strong></code></li></ul><ul id="122cdd59-aa66-49e4-8c01-05077b60ef0b" class="bulleted-list"><li style="list-style-type:disc">Use <code><strong>$text</strong></code> in a <code><strong>TextField</strong></code> to bind it bidirectionally:</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b2f7bcec-302c-499a-ba92-d103dc76be46" class="code"><code class="language-Swift">TextField(&quot;Enter text&quot;, text: $text)</code></pre><p id="dbd973dd-6753-4a3d-838c-e24803945ed4" class="">2. <code><strong>@Published</strong></code> property in an observed object or view model:</p><ul id="4f91555a-d4e9-44ca-b0c2-df10b9e1ac25" class="bulleted-list"><li style="list-style-type:disc">Access the value: <code><strong>username</strong></code></li></ul><ul id="2b8849b3-b5f5-44cd-aad2-4da9c497b4fa" class="bulleted-list"><li style="list-style-type:disc">The observed object or view model manages the state and publishes updates.</li></ul><ul id="40ba459a-61ae-4693-949e-a1ff577c9cb9" class="bulleted-list"><li style="list-style-type:disc">Views can observe the <code><strong>@Published</strong></code> property using <code><strong>@ObservedObject</strong></code> or <code><strong>@StateObject</strong></code>.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a52ed4b0-4b76-4d7e-a3b1-c0e06778b3c0" class="code"><code class="language-Swift">@ObservedObject var viewModel: ViewModel

// Use the `@Published` property in a view
Text(viewModel.username)</code></pre><p id="0bec79a4-1d37-45f9-9cd5-6eecb39855cf" class="">
</p><p id="2a2d7b02-bef8-4941-85cc-ce7d75dc2c07" class="">In summary, <code><strong>@State</strong></code> is used for local state within a view, and you use <code><strong>$</strong></code> to access a binding to the state. <code><strong>@Published</strong></code> is used for observed objects or view models, and views observe the published properties using <code><strong>@ObservedObject</strong></code> or <code><strong>@StateObject</strong></code>.</p><p id="6207b4c4-5027-4cbc-acf2-cf55285c0679" class="">
</p><p id="03e001cc-5749-449d-b7f9-6cce272df8e8" class="">So, the registrationIsValid of viewModel which is of type AnyPublisher&lt;Bool, Never&gt; cannot be accessed directly in the view to drive the .opacity and the .disabled. We need a ‘@State’ in the view (of type, simply Bool) that subscribes to the values emmited by the Publisher:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="25fa7021-d490-41f4-ab2c-605ca8e150a8" class="code"><code class="language-Swift">@State private var registrationIsValid = false
//...
onReceive(viewModel.registrationIsValid) { result in
			self.registrationIsValid = result
		}

// Could be done in a createBindings() ??</code></pre><p id="2bcb7d82-6d5f-4579-8eca-ab4c79b03372" class="">
</p><p id="520a916b-9611-4d4c-8ddd-8bf28b8b7725" class="">“The <code><strong>.eraseToAnyPublisher()</strong></code> method is not causing the crash itself. It is used to erase the specific type of the publisher (<code><strong>Publishers.CombineLatest&lt;...&gt;</strong></code>) and convert it to the <code><strong>AnyPublisher&lt;Bool, Never&gt;</strong></code> type, which is more generic. This is often done to hide implementation details and expose a more abstract publisher type to the consumers.”</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>
  </div>
</div>
</div>
</div>
    </div>
  </div>

</body>
</html>
